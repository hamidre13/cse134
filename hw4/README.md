README
This README describes some of the great aspects of our app, as well as some of its shortcomings. 

Admin area:
We used bootstrap to organize our admin area. We know it has flow, but because of time constraint and given it is admin area we decided to go for the bootstrap.
We use tag names as ids for our firebase DB. In edit mode tag name value should not get change because it will cause the tag to save as a new tag. Given that we did not have any type of server side  logic, then 

Front-end search bar:
	The search bar was tricky to implement due to the fact that no data is actually being posted to a server. The query strings are generated by dynamically editing the ‘href’ attribute of the search bar as the user types, or as the user switches search criteria. Whenever the user changes their search criteria, the ‘type’ value immediately changes in the query string. The ‘str’ value in the query string changes on the keypress event, so every time the user presses a key while typing in the box, the ‘href’ attribute completely refreshes. 
	When the search criteria is switched to ‘By Category’, the input switches from a textbox to a select list, because there are only twelve categories the user can choose from. Instead of taking the user to a ‘search results’ page, the user is taken to the ‘category-specific-tags’ page.
	There are three search criteria: 

By tag: If your search criteria is ‘By Tag’, the database will be queried by tag name. It does not matter if you put both braces, only one brace (either right or left), or no braces around the tag name - if the inner text matches a tag name, it will be found. ‘By Tag’ is the default criteria.
By attribute: If your search criteria is ‘By Attribute’, the database will be queried by attribute. All tags on which that attribute can be used will be found. 
By category: If your search criteria is ‘By Category’, the query will return all tags that fall into the selected category.

Dynamic Page Generation:
	When a user clicks on a category from either the reference page or the education page, the tiles for the tags in that category will be generated dynamically. The database is queried, and all of the tags pertaining to that category are pulled out, some html elements are created to hold them, and they are stuck in the DOM tree. Attributes that link them to the actual tag pages are filled in too.
	The search pages are obviously dynamically generated as well, with the same procedure: the criteria determines which branch of the JSON object to search, and the entered value determines what to search for. When searching ‘By Tag’ and ‘By Attribute’, each result is represented by the tag name as a link, then the tag definition below. A horizontal line delimits each result. When no results are found, a message appears stating so. 
	All links to tag info pages have their href attributes generated dynamically when the page loads. They are formed from the ‘data-name’ attribute that exists on the element in the markup. The content on the tag info page itself is generated by searching the ‘tags’ branch of the database, and looking for the value of the ‘tag’ key supplied in the query string. All of the children of this branch are used to fill in the various sections. 

Login and authentication:
	We did not have time to implement personal accounts for each user. Our login modals simply do not do anything, though implementing some functionality would not be difficult give more time. This also means that are favorites page is static, and does not actually render any one user’s favorite tags. 

Adding tags and attributes to the database:
	Adding to the ‘tags’ branch of our database is done with the set() firebase method. This means that if you were to add the same tag twice, the first instance would be overwritten and replaced with the new information. The attributes and categories lists are appended to with the firebase push() method. This means that the database does not distinguish between duplicates, so if you were to save the same tag twice, it would appear twice under all of its attributes, in the ‘attributes’ branch of the database. 
